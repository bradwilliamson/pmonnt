use super::{MalwareBazaarProvider, MbApiError, MbQueryMeta, MbTagInfoSample};

use log::{debug, warn};
use std::time::Duration;

impl MalwareBazaarProvider {
    pub fn get_taginfo(
        &self,
        tag: &str,
        limit: Option<u32>,
    ) -> Result<Vec<MbTagInfoSample>, MbApiError> {
        let mut meta = MbQueryMeta {
            last_query: Some("get_taginfo".to_string()),
            last_http_status: None,
            last_query_status: None,
            last_result_count: None,
            last_error_message: None,
        };
        // Get API key - required for MalwareBazaar
        let api_key = self
            .api_key
            .lock()
            .map_err(|_| MbApiError::NotConfigured)?
            .clone()
            .ok_or(MbApiError::NotConfigured)?;

        if self.is_rate_limited() {
            return Err(MbApiError::RateLimited);
        }

        let client = reqwest::blocking::Client::builder()
            .timeout(Duration::from_secs(30))
            .build()?;

        // Clamp limit to valid range (default 100, max 1000)
        let limit = limit.unwrap_or(100).clamp(1, 1000);

        let form = [
            ("query", "get_taginfo"),
            ("tag", tag),
            ("limit", &limit.to_string()),
        ];
        let response = client
            .post(Self::api_base_url())
            .header("Auth-Key", api_key)
            .form(&form)
            .send()?;

        let status = response.status();
        meta.last_http_status = Some(status.as_u16());
        debug!(
            "MalwareBazaar get_taginfo HTTP {} tag={}",
            status.as_u16(),
            tag
        );

        if status == 401 || status == 403 {
            let body = response.text().unwrap_or_default();
            warn!(
                "MalwareBazaar get_taginfo unauthorized ({}). body: {}",
                status.as_u16(),
                body.chars().take(1024).collect::<String>()
            );
            meta.last_error_message = Some("unauthorized".to_string());
            self.set_last_query_meta(meta);
            return Err(MbApiError::NotConfigured);
        }

        if status == 429 {
            let body = response.text().unwrap_or_default();
            warn!(
                "MalwareBazaar get_taginfo rate limited ({}). body: {}",
                status.as_u16(),
                body.chars().take(1024).collect::<String>()
            );
            self.set_rate_limited();
            meta.last_error_message = Some("rate_limited".to_string());
            self.set_last_query_meta(meta);
            return Err(MbApiError::RateLimited);
        }

        if !status.is_success() {
            let body = response.text().unwrap_or_default();
            warn!(
                "MalwareBazaar get_taginfo HTTP {}. body: {}",
                status.as_u16(),
                body.chars().take(1024).collect::<String>()
            );
            meta.last_error_message = Some(format!("http_{}", status.as_u16()));
            self.set_last_query_meta(meta);
            return Err(MbApiError::Http(status.as_u16()));
        }

        let json: serde_json::Value = response.json()?;
        let query_status = json
            .get("query_status")
            .and_then(|v| v.as_str())
            .unwrap_or("");
        meta.last_query_status = Some(query_status.to_string());
        match query_status {
            "ok" => {}
            "tag_not_found" | "no_results" => {
                meta.last_result_count = Some(0);
                self.set_last_query_meta(meta);
                return Ok(Vec::new());
            }
            "illegal_tag" => {
                meta.last_error_message = Some("illegal_tag".to_string());
                self.set_last_query_meta(meta);
                return Err(MbApiError::IllegalTag);
            }
            other => {
                meta.last_error_message = Some(format!("unexpected: {}", other));
                self.set_last_query_meta(meta);
                return Err(MbApiError::Http(400));
            }
        }

        let empty_vec = Vec::new();
        let data = json
            .get("data")
            .and_then(|v| v.as_array())
            .unwrap_or(&empty_vec);
        let samples = data
            .iter()
            .filter_map(|item| serde_json::from_value(item.clone()).ok())
            .collect::<Vec<_>>();
        meta.last_result_count = Some(samples.len());
        self.set_last_query_meta(meta);
        Ok(samples)
    }
}
