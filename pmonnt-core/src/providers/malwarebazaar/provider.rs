use super::{MalwareBazaarProvider, MbQueryMeta, MbSampleInfo};

use crate::local_cache::LocalCacheProvider;

use std::env;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

impl MalwareBazaarProvider {
    pub(in crate::providers::malwarebazaar) fn api_base_url() -> String {
        // Test hook: allow overriding the API base URL to point at a local test server.
        // Defaults to the real MalwareBazaar API endpoint.
        env::var("MB_BASE_URL").unwrap_or_else(|_| "https://mb-api.abuse.ch/api/v1/".to_string())
    }

    pub fn new(local_cache: Arc<LocalCacheProvider>, api_key: Option<String>) -> Self {
        // Priority: PMONNT_MB_API_KEY, fallback to PMONNT_MALWAREBAZAAR_KEY
        let env_key = env::var("PMONNT_MB_API_KEY")
            .ok()
            .or_else(|| env::var("PMONNT_MALWAREBAZAAR_KEY").ok());
        let api_key = api_key.or(env_key);
        Self {
            api_key: Arc::new(Mutex::new(api_key)),
            local_cache,
            rate_limit_until: Arc::new(Mutex::new(None)),
            last_query_meta: Arc::new(Mutex::new(None)),
            last_sample: Arc::new(Mutex::new(None)),
        }
    }

    /// Update the API key at runtime
    pub fn update_api_key(&self, api_key: Option<String>) {
        if let Ok(mut guard) = self.api_key.lock() {
            *guard = api_key;
        }
    }

    #[cfg(test)]
    pub(crate) fn get_api_key(&self) -> Option<String> {
        self.api_key.lock().ok().and_then(|g| g.clone())
    }

    pub fn get_last_query_meta(&self) -> Option<MbQueryMeta> {
        self.last_query_meta.lock().ok().and_then(|m| m.clone())
    }

    pub fn get_last_sample(&self) -> Option<MbSampleInfo> {
        self.last_sample.lock().ok().and_then(|s| s.clone())
    }

    pub(in crate::providers::malwarebazaar) fn set_last_query_meta(&self, meta: MbQueryMeta) {
        if let Ok(mut guard) = self.last_query_meta.lock() {
            *guard = Some(meta);
        }
    }

    pub(in crate::providers::malwarebazaar) fn is_rate_limited(&self) -> bool {
        if let Ok(rate_limit) = self.rate_limit_until.lock() {
            if let Some(until) = *rate_limit {
                if Instant::now() < until {
                    return true;
                }
            }
        }
        false
    }

    pub(in crate::providers::malwarebazaar) fn set_rate_limited(&self) {
        if let Ok(mut rate_limit) = self.rate_limit_until.lock() {
            *rate_limit = Some(Instant::now() + Duration::from_secs(60));
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_new_provider_with_explicit_key() {
        let temp = tempdir().unwrap();
        let cache = Arc::new(LocalCacheProvider::new(temp.path().join("cache.json")));
        let provider = MalwareBazaarProvider::new(cache, Some("test_key".to_string()));
        
        assert_eq!(provider.get_api_key(), Some("test_key".to_string()));
    }

    #[test]
    fn test_new_provider_without_key() {
        let temp = tempdir().unwrap();
        let cache = Arc::new(LocalCacheProvider::new(temp.path().join("cache.json")));
        let provider = MalwareBazaarProvider::new(cache, None);
        
        // May have env key or not, should not panic
        let _ = provider.get_api_key();
    }

    #[test]
    fn test_api_key_update() {
        let temp = tempdir().unwrap();
        let cache = Arc::new(LocalCacheProvider::new(temp.path().join("cache.json")));
        let provider = MalwareBazaarProvider::new(cache, Some("initial".to_string()));
        
        assert_eq!(provider.get_api_key(), Some("initial".to_string()));
        
        provider.update_api_key(Some("updated".to_string()));
        assert_eq!(provider.get_api_key(), Some("updated".to_string()));
        
        provider.update_api_key(None);
        assert!(provider.get_api_key().is_none());
    }

    #[test]
    fn test_multiple_api_key_updates() {
        let temp = tempdir().unwrap();
        let cache = Arc::new(LocalCacheProvider::new(temp.path().join("cache.json")));
        let provider = MalwareBazaarProvider::new(cache, Some("key1".to_string()));
        
        assert_eq!(provider.get_api_key(), Some("key1".to_string()));
        
        provider.update_api_key(Some("key2".to_string()));
        assert_eq!(provider.get_api_key(), Some("key2".to_string()));
        
        provider.update_api_key(Some("key3".to_string()));
        assert_eq!(provider.get_api_key(), Some("key3".to_string()));
    }

    #[test]
    fn test_last_query_meta_none_initially() {
        let temp = tempdir().unwrap();
        let cache = Arc::new(LocalCacheProvider::new(temp.path().join("cache.json")));
        let provider = MalwareBazaarProvider::new(cache, None);
        
        assert!(provider.get_last_query_meta().is_none());
    }

    #[test]
    fn test_last_sample_none_initially() {
        let temp = tempdir().unwrap();
        let cache = Arc::new(LocalCacheProvider::new(temp.path().join("cache.json")));
        let provider = MalwareBazaarProvider::new(cache, None);
        
        assert!(provider.get_last_sample().is_none());
    }

    #[test]
    fn test_rate_limit_initially_false() {
        let temp = tempdir().unwrap();
        let cache = Arc::new(LocalCacheProvider::new(temp.path().join("cache.json")));
        let provider = MalwareBazaarProvider::new(cache, None);
        
        assert!(!provider.is_rate_limited());
    }

    #[test]
    fn test_set_rate_limited_becomes_true() {
        let temp = tempdir().unwrap();
        let cache = Arc::new(LocalCacheProvider::new(temp.path().join("cache.json")));
        let provider = MalwareBazaarProvider::new(cache, None);
        
        provider.set_rate_limited();
        assert!(provider.is_rate_limited());
    }

    #[test]
    fn test_api_base_url_defaults() {
        // Without env var, should return default
        let url = MalwareBazaarProvider::api_base_url();
        assert!(url.contains("mb-api.abuse.ch") || url.contains("http"));
    }
}
