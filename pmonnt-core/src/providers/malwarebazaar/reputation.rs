use super::{MalwareBazaarProvider, MbQueryMeta};

use crate::hashing::is_valid_sha256;

use crate::reputation::{
    AggregatedReputation, LookupState, ProviderFinding, ReputationProvider, Verdict,
};

use std::time::Duration;

impl ReputationProvider for MalwareBazaarProvider {
    fn name(&self) -> &'static str {
        "MB"
    }

    fn lookup_hash(&self, sha256: &str) -> LookupState {
        if !is_valid_sha256(sha256) {
            return LookupState::Error("Invalid SHA256 hash".to_string());
        }
        // Check cache first
        let cache_key = format!("mb:{}", sha256);
        if let Some((cached, provider)) = self.local_cache.get_with_provider(&cache_key) {
            // Only return cached result if it was cached by this provider
            if provider.as_deref() == Some("MB") || provider.is_none() {
                return match cached {
                    // Cached positive hit is stored as VT-shaped stats; rehydrate into MB-shaped Aggregated.
                    LookupState::Hit(_) => {
                        let finding = ProviderFinding {
                            provider_name: "MB".to_string(),
                            verdict: Verdict::Malicious,
                            link: Some(format!("https://bazaar.abuse.ch/sample/{}", sha256)),
                            family: None,
                            confidence: None,
                        };

                        let agg = AggregatedReputation {
                            findings: vec![finding],
                            best_verdict: Verdict::Malicious,
                            summary: "MalwareBazaar: cached hit".to_string(),
                            primary_link: Some(format!(
                                "https://bazaar.abuse.ch/sample/{}",
                                sha256
                            )),
                        };

                        LookupState::Aggregated(agg)
                    }
                    other => other,
                };
            }
        }

        // Get API key - required for MalwareBazaar
        let api_key = self.api_key.lock().ok().and_then(|guard| guard.clone());
        if api_key.is_none() {
            return LookupState::NotConfigured;
        }

        if self.is_rate_limited() {
            return LookupState::Error("Rate limited".to_string());
        }

        let _client = match reqwest::blocking::Client::builder()
            .timeout(Duration::from_secs(5))
            .build()
        {
            Ok(c) => c,
            Err(_) => return LookupState::Offline,
        };

        // Use get_info_verbose to perform the request and update meta
        match self.get_info_verbose(sha256) {
            Ok((Some(sample), meta)) => {
                // store a simple VT-style stat to indicate found
                self.set_last_query_meta(meta);
                self.local_cache.store(
                    cache_key,
                    Some(crate::reputation::VtStats {
                        malicious: 1,
                        suspicious: 0,
                        harmless: 0,
                        undetected: 0,
                        last_analysis_date: None,
                    }),
                    false,
                    Some("MB"),
                );

                let finding = ProviderFinding {
                    provider_name: "MB".to_string(),
                    verdict: Verdict::Malicious,
                    link: Some(format!("https://bazaar.abuse.ch/sample/{}", sample.sha256)),
                    family: sample.signature.clone(),
                    confidence: None,
                };

                let agg = AggregatedReputation {
                    findings: vec![finding],
                    best_verdict: Verdict::Malicious,
                    summary: format!(
                        "MalwareBazaar: {}{}",
                        sample
                            .signature
                            .clone()
                            .unwrap_or_else(|| "found".to_string()),
                        if !sample.tags.is_empty() {
                            format!(" ({})", sample.tags.join(", "))
                        } else {
                            "".to_string()
                        }
                    ),
                    primary_link: Some(format!("https://bazaar.abuse.ch/sample/{}", sample.sha256)),
                };

                LookupState::Aggregated(agg)
            }
            Ok((None, meta)) => {
                self.set_last_query_meta(meta);
                self.local_cache.store(cache_key, None, true, Some("MB"));
                LookupState::NotFound
            }
            Err(e) => {
                // Convert some errors to LookupState
                let msg = format!("{}", e);
                self.set_last_query_meta(MbQueryMeta {
                    last_query: Some("get_info".to_string()),
                    last_http_status: None,
                    last_query_status: None,
                    last_result_count: None,
                    last_error_message: Some(msg.clone()),
                });
                LookupState::Error(msg)
            }
        }
    }
}
