use super::{MalwareBazaarProvider, MbApiError, MbDownloadResult};

use log::{debug, warn};
use std::fs::File;
use std::io::{Read, Write};
use std::path::Path;
use std::time::Duration;

impl MalwareBazaarProvider {
    pub fn download_sample(
        &self,
        sha256: &str,
        dest_dir: &Path,
    ) -> Result<MbDownloadResult, MbApiError> {
        // Get API key - required for MalwareBazaar
        let api_key = self
            .api_key
            .lock()
            .map_err(|_| MbApiError::NotConfigured)?
            .clone()
            .ok_or(MbApiError::NotConfigured)?;

        if self.is_rate_limited() {
            return Err(MbApiError::RateLimited);
        }

        let client = reqwest::blocking::Client::builder()
            .timeout(Duration::from_secs(30))
            .build()?;

        let form = [("query", "get_file"), ("sha256_hash", sha256)];
        let mut response = client
            .post(Self::api_base_url())
            .header("Auth-Key", api_key)
            .form(&form)
            .send()?;

        let status = response.status();
        debug!(
            "MalwareBazaar download_sample HTTP {} for {}",
            status.as_u16(),
            sha256
        );

        if status == 401 || status == 403 {
            let body = response.text().unwrap_or_default();
            warn!(
                "MalwareBazaar download_sample unauthorized ({}). body: {}",
                status.as_u16(),
                body.chars().take(1024).collect::<String>()
            );
            return Err(MbApiError::NotConfigured);
        }

        if status == 429 {
            let body = response.text().unwrap_or_default();
            warn!(
                "MalwareBazaar download_sample rate limited ({}). body: {}",
                status.as_u16(),
                body.chars().take(1024).collect::<String>()
            );
            self.set_rate_limited();
            return Err(MbApiError::RateLimited);
        }

        if !status.is_success() {
            let body = response.text().unwrap_or_default();
            warn!(
                "MalwareBazaar download_sample HTTP {}. body: {}",
                status.as_u16(),
                body.chars().take(1024).collect::<String>()
            );
            return Err(MbApiError::Http(status.as_u16()));
        }

        // Check for API-level errors
        let content_type = response
            .headers()
            .get("content-type")
            .and_then(|ct| ct.to_str().ok())
            .unwrap_or("");

        if content_type.contains("application/json") {
            let json: serde_json::Value = response.json()?;
            let query_status = json
                .get("query_status")
                .and_then(|v| v.as_str())
                .unwrap_or("");
            match query_status {
                "file_not_found" => return Err(MbApiError::FileNotFound),
                "illegal_sha256_hash" => return Err(MbApiError::IllegalSha256Hash),
                "no_sha256_hash" => return Err(MbApiError::NoSha256Hash),
                _ => return Err(MbApiError::Http(400)),
            }
        }

        // Stream to file
        let file_path = dest_dir.join(format!("{}.zip", sha256));
        let mut file = File::create(&file_path)?;
        let mut downloaded_size = 0u64;
        const MAX_SIZE: u64 = 100 * 1024 * 1024; // 100MB

        let mut buf = [0u8; 8192];
        loop {
            let bytes_read = response.read(&mut buf)?;
            if bytes_read == 0 {
                break;
            }
            downloaded_size += bytes_read as u64;
            if downloaded_size > MAX_SIZE {
                return Err(MbApiError::FileTooLarge);
            }
            file.write_all(&buf[..bytes_read])?;
        }

        Ok(MbDownloadResult {
            file_path,
            file_size: downloaded_size,
        })
    }
}
