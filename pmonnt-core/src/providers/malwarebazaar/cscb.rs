use super::{MalwareBazaarProvider, MbApiError, MbCscbEntry, MbQueryMeta};

use log::{debug, warn};
use std::time::Duration;

impl MalwareBazaarProvider {
    /// Get Code Signing Certificate Blocklist entries
    pub fn get_cscb(&self) -> Result<Vec<MbCscbEntry>, MbApiError> {
        let mut meta = MbQueryMeta {
            last_query: Some("get_cscb".to_string()),
            last_http_status: None,
            last_query_status: None,
            last_result_count: None,
            last_error_message: None,
        };

        let api_key = self
            .api_key
            .lock()
            .map_err(|_| MbApiError::NotConfigured)?
            .clone()
            .ok_or(MbApiError::NotConfigured)?;
        if self.is_rate_limited() {
            return Err(MbApiError::RateLimited);
        }

        let client = reqwest::blocking::Client::builder()
            .timeout(Duration::from_secs(30))
            .build()?;
        let form = [("query", "get_cscb")];
        let response = client
            .post(Self::api_base_url())
            .header("Auth-Key", api_key)
            .form(&form)
            .send()?;

        let status = response.status();
        meta.last_http_status = Some(status.as_u16());
        debug!("MalwareBazaar get_cscb HTTP {}", status.as_u16());

        if status == 401 || status == 403 {
            let body = response.text().unwrap_or_default();
            warn!(
                "MalwareBazaar get_cscb unauthorized ({}). body: {}",
                status.as_u16(),
                body.chars().take(1024).collect::<String>()
            );
            meta.last_error_message = Some("unauthorized".to_string());
            self.set_last_query_meta(meta);
            return Err(MbApiError::NotConfigured);
        }
        if status == 429 {
            let body = response.text().unwrap_or_default();
            warn!(
                "MalwareBazaar get_cscb rate limited ({}). body: {}",
                status.as_u16(),
                body.chars().take(1024).collect::<String>()
            );
            self.set_rate_limited();
            meta.last_error_message = Some("rate_limited".to_string());
            self.set_last_query_meta(meta);
            return Err(MbApiError::RateLimited);
        }
        if !status.is_success() {
            let body = response.text().unwrap_or_default();
            warn!(
                "MalwareBazaar get_cscb HTTP {}. body: {}",
                status.as_u16(),
                body.chars().take(1024).collect::<String>()
            );
            meta.last_error_message = Some(format!("http_{}", status.as_u16()));
            self.set_last_query_meta(meta);
            return Err(MbApiError::Http(status.as_u16()));
        }

        let json: serde_json::Value = response.json()?;
        let query_status = json
            .get("query_status")
            .and_then(|v| v.as_str())
            .unwrap_or("");
        meta.last_query_status = Some(query_status.to_string());

        match query_status {
            "ok" => {}
            "no_results" => {
                meta.last_result_count = Some(0);
                self.set_last_query_meta(meta);
                return Ok(Vec::new());
            }
            other => {
                meta.last_error_message = Some(format!("unexpected: {}", other));
                self.set_last_query_meta(meta);
                return Err(MbApiError::Http(400));
            }
        }

        let empty_vec = Vec::new();
        let data = json
            .get("data")
            .and_then(|v| v.as_array())
            .unwrap_or(&empty_vec);
        let mut out = Vec::new();
        for item in data.iter() {
            let time_stamp = item
                .get("time_stamp")
                .and_then(|v| v.as_str())
                .or_else(|| item.get("timestamp").and_then(|v| v.as_str()))
                .unwrap_or("")
                .to_string();
            let serial_number = item
                .get("serial_number")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            let thumbprint = item
                .get("thumbprint")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            let subject_cn = item
                .get("subject_cn")
                .and_then(|v| v.as_str())
                .or_else(|| item.get("subject").and_then(|v| v.as_str()))
                .unwrap_or("")
                .to_string();
            let issuer_cn = item
                .get("issuer_cn")
                .and_then(|v| v.as_str())
                .or_else(|| item.get("issuer").and_then(|v| v.as_str()))
                .unwrap_or("")
                .to_string();
            let valid_from = item
                .get("valid_from")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            let valid_to = item
                .get("valid_to")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            let cscb_listed = item
                .get("cscb_listed")
                .and_then(|v| v.as_bool())
                .or_else(|| item.get("listed").and_then(|v| v.as_bool()))
                .unwrap_or(false);
            let cscb_reason = item
                .get("cscb_reason")
                .and_then(|v| v.as_str())
                .unwrap_or("")
                .to_string();
            out.push(MbCscbEntry {
                time_stamp,
                serial_number,
                thumbprint,
                subject_cn,
                issuer_cn,
                valid_from,
                valid_to,
                cscb_listed,
                cscb_reason,
            });
        }
        meta.last_result_count = Some(out.len());
        self.set_last_query_meta(meta);
        Ok(out)
    }
}
